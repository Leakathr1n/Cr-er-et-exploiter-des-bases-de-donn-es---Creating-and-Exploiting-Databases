 /*
 *		TECH.20712 -- Gestion des bases de données
 *		
 *		HEC Montréal,
 *		Travail Pratique 4
 *		
 *		Instructions de remise : 
 *			-Répondre aux questions directement dans ce fichier .sql
 *			-A remettre via ZoneCours dans l'outil de remise de travaux
 *
 *		Correction : 
 *			- 12.5% de la note finale
 *			- Une question qui génère une erreur (ne s'exécute pas) se verra automatique attribuer la note de 0.
 *
 */
Use AdventureWorks2019
GO
/*
	Question #1 : (FINI!)
		Votre nouvel ami à vie, Monsieur le Directeur de ventes, s’intéresse maintenant aux détails de la plus grande vente enregistrée par 
		AdventureWorks au premier trimestre 2014. Il veut obtenir les détails suivant :
			-le numéro de commande
			-le total du, en incluant les taxes, transport, etc.
			-la date de commande
			-l'identification (ID) du vendeur qui a fait la vente
			-le nom et le prénom du vendeur qui a fait la vente, le tout dans 1 seule cellule!
			-la quantité (OrderQty) totale de produits inclus dans la commande 

		Il prend la peine de vous mentionner qu'il ne veut que les détails de cette vente (la plus grosse enregistrée par AdventureWorkds au 1er 
		trimestre de 2014). Il s'attend donc à ce que vous lui donniez une seule ligne de résultat.

		Note: vous vous souvenez qu’à HEC vous avez appris que pour trouver les transactions par trimestre vous pouvez utiliser 
		des fonctions built-in. Par exemple,		
		
		YEAR(SalesOrderHeader.OrderDate)=2014 AND DATEPART(QUARTER, SalesOrderHeader.OrderDate)=1
		 
		Note: Vous remarquez qu'il peut y avoir plusieurs facons de répondre à cette requete, on vous demande de le faire en utilisant des sous-requetes. 
*/

SELECT 
    SOH.SalesOrderNumber AS 'Numéro de commande', -- -le numéro de commande
    SOH.TotalDue AS 'Total (Taxes, transport, etc.)', -- le total du, en incluant les taxes, transport, etc.
    SOH.OrderDate AS 'Date de commande', -- la date de commande
    SOH.SalesPersonID AS 'ID du vendeur', -- l'identification (ID) du vendeur qui a fait la vente
    CONCAT(PP.FirstName, ' ', PP.LastName) AS 'Nom et prénom du vendeur',  -- le nom et le prénom du vendeur qui a fait la vente, le tout dans 1 seule cellule!
    (SELECT SUM(OrderQty) FROM Sales.SalesOrderDetail WHERE SalesOrderID = SOH.SalesOrderID) AS 'Quantité totale de produits'
FROM 
    Sales.SalesOrderHeader AS SOH
INNER JOIN 
    Person.Person AS PP ON SOH.SalesPersonID = PP.BusinessEntityID
WHERE 
    YEAR(SOH.OrderDate) = 2014 AND -- 2014
    DATEPART(QUARTER, SOH.OrderDate) = 1 AND -- premiere trimestre
    SOH.TotalDue = (
        SELECT MAX(TotalDue) -- la vente la plus grosse
        FROM Sales.SalesOrderHeader 
        WHERE YEAR(OrderDate) = 2014 AND DATEPART(QUARTER, OrderDate) = 1 )-- 2014 & premiere trimestre 

-- la solution

SELECT
	  soh.SalesOrderNumber	AS 'Numéro commande'
	, soh.TotalDue			AS 'Total du'
	, soh.OrderDate			AS 'Date commande'
	, soh.SalesPersonID		AS 'ID vendeur'
	, CONCAT(p.FirstName,' ',LastName) AS 'Prénom et nom vendeur'
	, SUM(sod.OrderQty)		AS 'Quantité de produits'
FROM sales.SalesOrderHeader soh
	INNER JOIN Sales.SalesOrderDetail sod	ON soh.SalesOrderID = sod.SalesOrderID
	INNER JOIN Person.Person p				ON p.BusinessEntityID = soh.SalesPersonID
WHERE YEAR(soh.OrderDate)=2014 AND DATEPART(QUARTER, soh.OrderDate)=1
	AND soh.TotalDue >= ALL
		(
		SELECT soh2.TotalDue
		FROM sales.SalesOrderHeader soh2
		WHERE YEAR(soh2.OrderDate)=2014 AND DATEPART(QUARTER, soh2.OrderDate)=1)
GROUP BY soh.SalesOrderNumber, soh.TotalDue, soh.OrderDate, soh.SalesPersonID, p.FirstName, p.LastName



/*
	Question #2 : (FINI)
		Le directeur des ventes aimerait aussi savoir quelles sont les boutiques dont le montant commandé (avant taxes et transport) (subTotal)
		au premier trimestre 2014 est supérieur à la moyenne du montant commandé (avant taxes et transport) du dernier trimestre de 2013. 
		Évidemment, il ne s'agit que des ventes en magasin.
		
		Il mentionne qu'il veut retrouver dans la liste uniquement l'ID du magasin et son nom ordonné du plus petit au plus grand ID de magasin.
		
		le haut de la table obtenue ressemble à ceci

		ID Magasin	|	Nom magasin
		-----------------------------------------------
		294			|	Professional Sales and Service
		296			|	Riders Company
		300			|	Nationwide Supply

*/


SELECT 
    C.StoreID AS 'ID Magasin', -- ID Magasin
    S.Name AS 'Nom magasin' -- Nom magasin
FROM 
    Sales.Customer AS C
INNER JOIN 
    Sales.SalesOrderHeader AS SOH ON C.CustomerID = SOH.CustomerID
INNER JOIN 
    Sales.Store AS S ON C.StoreID = S.BusinessEntityID
WHERE 
    C.StoreID IS NOT NULL -- il ne s'agit que des ventes en magasin
    AND YEAR(SOH.OrderDate) = 2014 --  2014
    AND DATEPART(QUARTER, SOH.OrderDate) = 1  -- au premier trimestre 
    AND SOH.SubTotal > ( --  moyenne du montant commandé (avant taxes et transport) du dernier trimestre de 2013
        SELECT AVG(SubTotal) -- à la moyenne
        FROM Sales.SalesOrderHeader 
        WHERE YEAR(OrderDate) = 2013  --  2013
        AND DATEPART(QUARTER, OrderDate) = 4 -- dernier trimestre
    )
ORDER BY 
    C.StoreID; -- le haut de la table obtenue ressemble à ceci

	
-- la solution

SELECT 
	  s.BusinessEntityID	AS 'ID magasin'
	, s.Name				AS 'Nom magasin'
FROM sales.SalesOrderHeader soh 
	INNER JOIN Sales.Customer c	ON c.CustomerID = soh.CustomerID
	LEFT JOIN Sales.Store s		ON s.BusinessEntityID = c.StoreID
WHERE soh.OnlineOrderFlag = 0 AND OrderDate BETWEEN '2014-01-01' AND '2014-03-31'
GROUP BY  s.BusinessEntityID, s.Name
HAVING SUM(soh.SubTotal) >
		(
		SELECT AVG(A.Sales2013)
		FROM
			(
			SELECT SUM(soh.SubTotal)	AS 'Sales2013'
			FROM sales.SalesOrderHeader soh
				INNER JOIN Sales.Customer c	ON c.CustomerID = soh.CustomerID
				LEFT JOIN Sales.Store s		ON s.BusinessEntityID = c.StoreID
			WHERE soh.OnlineOrderFlag = 0 AND YEAR(OrderDate) = 2013 AND DATEPART(QUARTER, OrderDate)=4
			GROUP BY  s.BusinessEntityID
			) as A
		)
ORDER BY 1





--Question 3: (FINI)
/*
Adventure works sait que la documentation de ses produits doit etre améliorée.
le directeur de la production, vous demande de sortir le nom des employés responsables 
des produits pour lesquels il n'y a pas de documents
la meme requete aussi retournera le nom de chacun des employés (last name de la table Personne) et 
le nombre de produits sous leur responsabilités dont la documentation est existante
*/

-- Adventure works sait que la documentation de ses produits doit etre améliorée.
-- le directeur de la production, vous demande de sortir le nom des employés responsables 
-- des produits pour lesquels il n'y a pas de documents

SELECT 
    PP.LastName AS 'Nom de l''employé', --- nom des employés responsables
    COUNT(DISTINCT P.ProductID) AS 'Nombre de produits sans documentation'  -- pour lesquels il n'y a pas de documents
FROM 
    Production.Product AS P
LEFT JOIN 
    Sales.SalesOrderDetail AS SOD ON P.ProductID = SOD.ProductID
LEFT JOIN 
    Sales.SalesOrderHeader AS SOH ON SOD.SalesOrderID = SOH.SalesOrderID
LEFT JOIN 
    Person.Person AS PP ON SOH.SalesPersonID = PP.BusinessEntityID
WHERE 
    P.ProductID NOT IN (SELECT ProductID FROM Production.ProductDocument) --  pour lesquels il n'y a pas de documents
GROUP BY 
    PP.LastName;


-- la meme requete aussi retournera le nom de chacun des employés (last name de la table Personne) et 
-- le nombre de produits sous leur responsabilités dont la documentation est existante

SELECT 
    PP.LastName AS 'Nom de l''employé', -- le nom de chacun des employés (last name de la table Personne
    COUNT(DISTINCT P.ProductID) AS 'Nombre de produits avec documentation' -- dont la documentation est existante
FROM 
    Production.Product AS P
INNER JOIN 
    Sales.SalesOrderDetail AS SOD ON P.ProductID = SOD.ProductID
INNER JOIN 
    Sales.SalesOrderHeader AS SOH ON SOD.SalesOrderID = SOH.SalesOrderID
INNER JOIN 
    Person.Person AS PP ON SOH.SalesPersonID = PP.BusinessEntityID
WHERE 
    P.ProductID IN (SELECT ProductID FROM Production.ProductDocument) -- dont la documentation est existante
GROUP BY 
    PP.LastName;


-- combination;

SELECT 
    PP.LastName AS 'Nom de l''employé',
    (
        SELECT COUNT(DISTINCT P.ProductID)
        FROM Production.Product AS P
        LEFT JOIN Sales.SalesOrderDetail AS SOD ON P.ProductID = SOD.ProductID
        LEFT JOIN Sales.SalesOrderHeader AS SOH ON SOD.SalesOrderID = SOH.SalesOrderID
        LEFT JOIN Person.Person AS PP ON SOH.SalesPersonID = PP.BusinessEntityID
        WHERE P.ProductID NOT IN (SELECT ProductID FROM Production.ProductDocument)
        AND PP.BusinessEntityID = E.BusinessEntityID
    ) AS 'Nombre de produits sans documentation', -- -- pour lesquels il n'y a pas de documents
    (
        SELECT COUNT(DISTINCT P.ProductID)
        FROM Production.Product AS P
        INNER JOIN Sales.SalesOrderDetail AS SOD ON P.ProductID = SOD.ProductID
        INNER JOIN Sales.SalesOrderHeader AS SOH ON SOD.SalesOrderID = SOH.SalesOrderID
        INNER JOIN Person.Person AS PP ON SOH.SalesPersonID = PP.BusinessEntityID
        WHERE P.ProductID IN (SELECT ProductID FROM Production.ProductDocument)
        AND PP.BusinessEntityID = E.BusinessEntityID
    ) AS 'Nombre de produits avec documentation' -- dont la documentation est existante
FROM 
    Person.Person AS PP
INNER JOIN 
	 HumanResources.Employee AS E ON PP.BusinessEntityID = E.BusinessEntityID
GROUP BY 
    PP.LastName, E.BusinessEntityID;

-- la solution

select PPER.LastName, count(PD.DocumentNode)
from 
PRoduction.Product PP
left join Production.ProductDocument PPD on PP.ProductID = PPD.ProductID
left join Production.Document PD on PPD.DocumentNode = PD.DocumentNode
left join Person.Person PPer on PPEr.BusinessEntityID = PD.Owner
where PD.Title is not null
group by PPER.LastName




-- Question 4: (FINI)

/* --Adventureworks compte devenir une entreprise mondiale l'année prochaine. 
Elle doit maitenant se préparer à pouvoir livrer partout sur la planete.
le département de livraison va séparer la planète en 5 sections
	1. Nord Est (NE)
	2. Nord Ouest (NO)
	3. Sud Est (SE)
	4. Sud Ouest (SO)
	5. équateur (Équateur)
On vous demande de créer une fonction qui s'appelera TrouveCaridalite qui va retourner en texte la section du globle basé sur les coordonées entrées
si la latitude est égale à 0, la fonction retournera 'Équateur'
si la latitude est superieure à 0 et plus petite que 90 , la fonction retournera Nord
si la longitude donneé est entre 0 et 180, la fonction retournera Est
si la longitude donneé est entre 0 (inclusivement) et -180, la fonction retournera Ouest
...
si les valeures de la latitude sont plus petite que -90 ou plus grande que 90, on retournera Erreur
si les valeures de la longitude sont plus petite que -180 ou plus grande que 180, on retournera Erreur
*/

-- J'ai utilisé ce code pour re-definir la fonctione TrouveCardinalite
DROP FUNCTION dbo.TrouveCardinalite


--declarer la fonctione
CREATE FUNCTION TrouveCardinalite (@latitude DECIMAL(9,6), @longitude DECIMAL(9,6))
RETURNS NVARCHAR(50)
AS
BEGIN
    DECLARE @result NVARCHAR(50)

    IF @latitude = 0
        SET @result = 'Équateur' -- si la latitude est égale à 0, la fonction retournera 'Équateur'
    ELSE IF @latitude > 0 AND @latitude < 90 
        SET @result = 'N' -- si la latitude est superieure à 0 et plus petite que 90 , la fonction retournera Nord
    ELSE IF @latitude < 0 AND @latitude > -90
        SET @result = 'S'
    ELSE
        SET @result = 'Erreur' -- si les valeures de la latitude sont plus petite que -90 ou plus grande que 90, on retournera Erreur

	IF @result = 'Équateur' AND @longitude <= 180 AND @longitude >= -180 -- si la latitude est égale à 0, la fonction retournera 'Équateur'
			SET @result = @result + ''
	ELSE IF @result = 'Erreur' -- si les valeures de la longitude sont plus petite que -180 ou plus grande que 180, on retournera Erreur
		SET @result = @result + ''
    ELSE IF @longitude >= 0 AND @longitude <= 180 
        SET @result = @result + 'E' -- si la longitude donneé est entre 0 et 180, la fonction retournera Est
    ELSE IF @longitude < 0 AND @longitude >= -180
        SET @result = @result + 'O' -- si la longitude donneé est entre 0 (inclusivement) et -180, la fonction retournera Ouest
    ELSE
        SET @result = 'Erreur' 

    RETURN @result
END;

-- la solution 
go
create function TrouveCaridalite ( @lat float , @lon float) 
returns char(10)
as

begin
declare @cardinatité char(10);
if (@lat > 90 or @lat < -90 or @lon > 180 or @lon <-180)
	set @cardinatité = 'Erreur'
else if (@lat = 0)	
	set @cardinatité = 'Équateur'
else if @lat > 0 and @lon > 0 
	set @cardinatité = 'NE'
else if @lat > 0 and @lon <= 0 
	set @cardinatité = 'NO'
else if @lat < 0 and @lon > 0 
	set @cardinatité = 'SE'
else if @lat < 0 and @lon <= 0 
	set @cardinatité = 'SO'

return @cardinatité
end
go




-- voila des exemples pour tester votre code

select dbo.TrouveCardinalite(0,10) -- retourne 'Équateur' / OUI
select dbo.TrouveCardinalite(0,-210) -- retourne 'Erreur' /OUI
select dbo.TrouveCardinalite(923,10) -- retourne 'Erreur' / OUI
select dbo.TrouveCardinalite(50.59,110) -- retourne 'NE' / OUI
select dbo.TrouveCardinalite(-30,-178) -- retourne 'SO' / OUI
select dbo.TrouveCardinalite(45.54,-70) -- retourne 'NO' / OUI
select dbo.TrouveCardinalite(-60,50) -- retourne 'SE' / OUI


 /*
=>Question 5 - Creation de la vue: vTotalWebSalesPerCustomer.  (FINI)
	Pour les commandes faites en ligne, créer une vue qui affiche le montant vendu total par client(avant taxes et transport) (Subtotal)
	au premier trimestre de 2014. 

	Ne retenir que les attributs suivants : 
	- CustomerID
	- Nom complet du client dans le format suivant (1 seule cellule) : 
			- Title LastName, FirstName --  *Attention pour les noms à bien retirer tout espace extra avant ou après le texte*
	- Montant total acheté par client (web)
	- On vous demande d'ajouter une colonne "Importance du client" dans laquelle vous ajouterez les commentaires suivants: 
	  Si le montant total acheté par le client est                     inférieur ou égal à 1000 --> "Client sans importance"
	  Si le montant total acheté par le client est supérieur à 1000 et inférieur ou égal à 2000 --> "Client peu important"
	  Si le montant total acheté par le client est supérieur à 2000 et inférieur ou égal à 3000 --> "Client tres important"
	  Si le montant total acheté par le client est supérieur à 3000								--> "Client VIP"
	 
*/


DROP FUNCTION udfClientImportance

CREATE FUNCTION udfClientImportance(@TotalSumPerWebCustomer DECIMAL(18, 2))
RETURNS NVARCHAR(50)
AS
BEGIN
    DECLARE @Importance NVARCHAR(50)

    IF @TotalSumPerWebCustomer <= 1000
        SET @Importance = 'Client sans importance'; --  Si le montant total acheté par le client est inférieur ou égal à 1000 --> "Client sans importance"
    ELSE IF @TotalSumPerWebCustomer > 1000 AND @TotalSumPerWebCustomer <= 2000 
        SET @Importance = 'Client peu important'; -- Si le montant total acheté par le client est supérieur à 1000 et inférieur ou égal à 2000 --> "Client peu important"
    ELSE IF @TotalSumPerWebCustomer > 2000 AND @TotalSumPerWebCustomer <= 3000
        SET @Importance = 'Client tres important'; --  Si le montant total acheté par le client est supérieur à 2000 et inférieur ou égal à 3000 --> "Client tres important"
    ELSE
        SET @Importance = 'Client VIP';  -- Si le montant total acheté par le client est supérieur à 3000								--> "Client VIP"

    RETURN @Importance;
END;
GO

-- J'ai utilisé ce code pour supprimer et re-definir la vue: vTotalWebSalesPerCustomer
DROP VIEW IF EXISTS vTotalWebSalesPerCustomer;

CREATE VIEW vTotalWebSalesPerCustomer AS
SELECT
    SOH.CustomerID AS 'ID client', -- CustomerID
    P.LastName + ', ' + P.FirstName AS 'FullName', -- Nom complet du client dans le format suivant (1 seule cellule) :
    SUM(SOH.SubTotal) AS 'TotalSumPerWebCustomer', -- Montant total acheté par client (web); (avant taxes et transport) (Subtotal)
    dbo.udfClientImportance(SUM(SOH.SubTotal)) AS 'Importance du Client'
FROM
    Sales.SalesOrderHeader AS SOH
INNER JOIN
    Person.Person AS P ON SOH.CustomerID = P.BusinessEntityID 
WHERE
    SOH.OnlineOrderFlag = 1  -- commandes faites en ligne
    AND YEAR(SOH.OrderDate) = 2014 --  2014
    AND DATEPART(QUARTER, SOH.OrderDate) = 1 -- premier trimestre 
GROUP BY
    SOH.CustomerID, P.LastName, P.FirstName;

-- on peut faire la meme chose en utislisant CASE


/*-- Validation de la vue
	En validant votre vue, on vous demande de garder que les clients VIPs dans votre requête sur votre nouvelle vue
	votre requete ressemblera à ceci

	ID client	|	FullName			|	TotalSumPerWebCustomer	| Importance du Client
	17192		|	He, Warren			|	4796.02					|	Client VIP
	17199		|	Zhou, Dennis		|	4816.00					|	Client VIP
	17209		|	James, Jacqueline	|	4739.05					|	Client VIP
	17220		|	Wang, Glenn			|	4733.29					|	Client VIP
*/

-- les personnes sont differentes - c'est ou le problème?

SELECT * 
FROM  vTotalWebSalesPerCustomer
WHERE TotalSumPerWebCustomer >3000
ORDER BY TotalSumPerWebCustomer;

-- par exemple, He, Warren n'existe pas dans ma table

SELECT *
FROM vTotalWebSalesPerCustomer
WHERE FullName = 'He, Warren';


-- la solution
IF OBJECT_ID ('vTotalWebSalesPerCustomer', 'V') IS NOT NULL  
	DROP VIEW vTotalWebSalesPerCustomer ; 
GO

CREATE VIEW vTotalWebSalesPerCustomer AS
SELECT
	  soh.CustomerID	AS 'ID client'
	, CASE 
		WHEN p.Title IS NULL THEN p.LastName + ', ' + p.FirstName
		ELSE p.Title + ' ' + p.LastName + ', ' + p.FirstName
		END				AS 'FullName'
	, SUM(soh.SubTotal) AS TotalSumPerWebCustomer,
	case
		when SUM(soh.SubTotal) <= 1000 then 'Client sans importance'
		when SUM(soh.SubTotal) > 1000 and SUM(soh.SubTotal) <= 2000 then 'Client avec peu important'
		when SUM(soh.SubTotal) > 2000 and SUM(soh.SubTotal) <= 3000 then 'Client tres important'
		when SUM(soh.SubTotal) > 3000 then 'Client VIP'
	end as [Importance du client]
FROM sales.SalesOrderHeader soh 
	INNER JOIN sales.Customer c	ON c.CustomerID = soh.CustomerID
	LEFT JOIN person.Person p	ON p.BusinessEntityID = c.PersonID
WHERE soh.OnlineOrderFlag = 1 AND YEAR(OrderDate)=2014 AND DATEPART(QUARTER, OrderDate)=1
GROUP BY soh.CustomerID, p.Title, p.FirstName, p.LastName
GO