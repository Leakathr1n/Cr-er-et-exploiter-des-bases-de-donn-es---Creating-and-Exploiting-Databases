
/* Date de Soumission:
Noms: Lea Roeller, Karen Assi, Dylan Jasaron
*/ 

USE MPD_SPVM
GO


/* 
Questions d’analyse et de conception :
1. (FINI)
Votre superviseur de stage s’interroge sur la faculté de la base de données actuelle à 
garder trace de changements éventuels d’affectations d’un agent de police à différents postes 
de quartier à travers le temps. En effet, le SPVM est doté d’une politique permettant à un 
agent de police de changer d’affectation de poste de quartier pendant sa carrière.
*/ 


/*
1.1. Expliquer pourquoi la base de données telle que conçue, ne permet pas de consigner convenablement 
de tels changements d’affectation à travers le temps, afin de pouvoir l’interroger sur ces 
intervalles de temps d’affectation éventuels.

 Réponse: La base de données n'inclut pas de date de début/fin par PDQ.  
 L'agent peut éventuellement changer de poste, mais la base de données n'enregistrera pas ce changement, 
 ou du moins pas la date du changement.
*/ 

 /*
1.2. Expliquer comment vous devriez modifier le modèle logique pour que le besoin fonctionnel décrit à la question 1 soit 
implémenté.

Réponse: On peut créer une table intermédiaire avec le détail des changements, indiquant les dates d'arrivée et de départ de chaque agent pour chaque PDQ. 
pour chaque PDQ. 

*/

/*
1.3. Advenant une telle amélioration de la base de données (question 1.2), il vous demande s’il était nécessaire 
d’implémenter des déclencheurs « triggers » afin d’assurer le maintien de l’intégrité des données lors d’insertion / mise à-jour éventuelle de données.

Rèponse: Oui, un déclencheur AFTER INSERT pourrait être utile pour vérifier qu'un agent ne travaille pas en même temps dans deux PDQ différents. 
En outre, nous pouvons créer un déclencheur UPDATE sur PDQ dans la table Agent. 
*/ 
--------------------------------------------------------------------------------------------------------------------------------------------------
 /* 2. (FINI)
 Écrire la fonction « udfGetStatsInterventions » qui reçoit un paramètre de type chaine d’exactement 3 caractères 
précisant une statistique à calculer sur les interventions enregistrées et retourne la valeur scalaire entière représentant cette 
statistique.
*/ 


DROP FUNCTION dbo.udfGetStatsInterventions;

CREATE FUNCTION dbo.udfGetStatsInterventions (@statistique NVARCHAR(3)) 
RETURNS INT
AS
BEGIN
    DECLARE @result INT; 

    IF @statistique = 'MIN'
    BEGIN
        SELECT @result = MIN(NOMBRE_INTERVENTIONS) 
        FROM (
            SELECT COUNT(DISTINCT IA.ID_INTERVENTION) AS NOMBRE_INTERVENTIONS
            FROM INTERVENTION_AGENT AS IA 
            INNER JOIN AGENT AS A ON IA.MATRICULE_AGENT = A.MATRICULE
            INNER JOIN POSTE_DE_QUARTIER AS PDQ ON A.PDQ = PDQ.ID_PDQ
            GROUP BY PDQ.ID_PDQ
        ) AS StatsMPD_SPVM
    END
    ELSE IF @statistique = 'MAX'
    BEGIN
        SELECT @result = MAX(NOMBRE_INTERVENTIONS) 
        FROM (
            SELECT COUNT(DISTINCT IA.ID_INTERVENTION) AS NOMBRE_INTERVENTIONS
            FROM INTERVENTION_AGENT AS IA
            INNER JOIN AGENT AS A ON IA.MATRICULE_AGENT = A.MATRICULE
            INNER JOIN POSTE_DE_QUARTIER AS PDQ ON A.PDQ = PDQ.ID_PDQ
            GROUP BY PDQ.ID_PDQ
        ) AS StatsMPD_SPVM
    END
    ELSE IF @statistique = 'MOY'
    BEGIN
        SELECT @result = AVG(NOMBRE_INTERVENTIONS) 
        FROM (
            SELECT COUNT(DISTINCT IA.ID_INTERVENTION) AS NOMBRE_INTERVENTIONS
            FROM INTERVENTION_AGENT AS IA
            INNER JOIN AGENT AS A ON IA.MATRICULE_AGENT = A.MATRICULE
            INNER JOIN POSTE_DE_QUARTIER AS PDQ ON A.PDQ = PDQ.ID_PDQ
            GROUP BY PDQ.ID_PDQ
        ) AS StatsMPD_SPVM
    END
    ELSE IF @statistique = 'TOT'
    BEGIN
        SELECT @result = SUM(NOMBRE_INTERVENTIONS) 
        FROM (
            SELECT COUNT(DISTINCT IA.ID_INTERVENTION) AS NOMBRE_INTERVENTIONS
            FROM INTERVENTION_AGENT AS IA
            INNER JOIN AGENT AS A ON IA.MATRICULE_AGENT = A.MATRICULE
            INNER JOIN POSTE_DE_QUARTIER AS PDQ ON A.PDQ = PDQ.ID_PDQ
            GROUP BY PDQ.ID_PDQ
        ) AS StatsMPD_SPVM
    END
    ELSE
    BEGIN
        SET @result = -1;
    END

    RETURN @result;
END;


-- Traces d’exécution :
PRINT [dbo].udfGetStatsInterventions('MIN'); -- Affiche 62 (OUI)
PRINT [dbo].udfGetStatsInterventions('MAX'); -- Affiche 12993 (OUI)
PRINT [dbo].udfGetStatsInterventions('MOY'); -- Affiche 5466 (OUI)
PRINT [dbo].udfGetStatsInterventions('TOT'); -- Affiche 180389  (OUI)
PRINT [dbo].udfGetStatsInterventions('N/D'); -- Affiche -1 (OUI)

----------------------------------------------------------------------------------------------------------------------------------
/* 
3. (FINI)
Écrire une requête SQL permettant de retourner le nombre total d’interventions répertoriées par poste de quartier, le 
pourcentage que représente ce nombre par rapport aux total des interventions dans la BD ainsi qu’une remarque pour les 
postes de quartiers respectant les critères ci-dessous :
- La colonne pourcentage doit être affichée avec exactement 4 décimales et minimalement les unités de pourcentage 
(valeurs entre 0 et 9). Il faudra également ajouter le signe de pourcentage à droite de la valeur du pourcentage (séparés 
par un espace).
- Les résultats devront être ordonnés par poste de quartier. 
*/ 


-- Créer des variables


DECLARE 
    @TOTAL_INTERVENTIONS INT, 
    @MOYENNE INT, 
    @MINIMUM INT, 
    @MAXIMUM INT;

SELECT 
    @TOTAL_INTERVENTIONS = [dbo].udfGetStatsInterventions('TOT'),
    @MOYENNE = [dbo].udfGetStatsInterventions('MOY'),
    @MINIMUM = [dbo].udfGetStatsInterventions('MIN'),
    @MAXIMUM = [dbo].udfGetStatsInterventions('MAX');

-- Utiliser les variables
SELECT
    PDQ.ID_PDQ AS 'Poste de quartier',
    COUNT(*) AS 'Total Interventions',
    FORMAT((CAST(COUNT(*) AS DECIMAL) / @TOTAL_INTERVENTIONS), '0.#### %') AS '% du nb. total d''interventions par PDQ',
    CASE
        WHEN COUNT(*) = @MINIMUM THEN 'PDQ avec le moins d''interventions répertoriées'
        WHEN COUNT(*) = @MAXIMUM  THEN 'PDQ avec le plus d''interventions répertoriées'
        WHEN COUNT(*) BETWEEN (@MOYENNE  * 0.9) AND (@MOYENNE * 1.1) THEN 'PDQ avec un nombre d''interventions proche de la moyenne'
        WHEN COUNT(*) <= (@MOYENNE  * 0.5) THEN 'PDQ avec un nombre relativement faible d''interventions'
        WHEN COUNT(*) >= (@MOYENNE * 1.5) THEN 'PDQ avec un nombre important d''interventions'
        ELSE ''
    END AS 'Remarque'
FROM
    INTERVENTION_AGENT AS IA
INNER JOIN
    AGENT AS A ON IA.MATRICULE_AGENT = A.MATRICULE
INNER JOIN
    POSTE_DE_QUARTIER AS PDQ ON A.PDQ = PDQ.ID_PDQ
GROUP BY
    PDQ.ID_PDQ
ORDER BY
    PDQ.ID_PDQ;

-----------------------------------------------------------------------------------------------------------------------------------------------

/* 4. (FINI)
Écrire une procédure stockée dont l’identificateur est « spInitSuiviInterventions » et qui permet de créer et peupler 
une table nommée « suiviInterventions » renfermant le nombre d’interventions policières répertoriées par quart de 
travail, pour chaque (année-mois) et chaque poste de quartier (voir structure de ci-dessous).
Suite à l’exécution d’une telle procédure stockée, la requête 
SELECT * FROM suiviInterventions ORDER BY 1, 2, 3; 
retournera les résultats dont voici un extrait (à analyser) :
*/
/*

Nous rencontrons toujours des difficultés lorsque nous essayons de convertir la date ou d'en extraire des informations. 
Nous avons donc utilisé la fonction DATEFROMPARTS()
https://www.w3schools.com/sqL/func_sqlserver_datefromparts.asp
*/

DROP PROCEDURE IF EXISTS spInitSuiviInterventions;
GO

CREATE PROCEDURE spInitSuiviInterventions
AS
BEGIN
	  -- Créer une table
    CREATE TABLE suiviInterventions (
        PosteDeQuartier INT,
        AnneeMois DATE,
        QuartDeTravail NVARCHAR(50),
        NbInterventionsRepertoriees INT,
        PRIMARY KEY (PosteDeQuartier, AnneeMois, QuartDeTravail)
    );

    -- Inserer des données
    INSERT INTO suiviInterventions (PosteDeQuartier, AnneeMois, QuartDeTravail, NbInterventionsRepertoriees)
    SELECT
        PDQ.ID_PDQ AS PosteDeQuartier,
        DATEFROMPARTS(YEAR(I.DATE_INCIDENT), MONTH(I.DATE_INCIDENT), 1) AS AnneeMois,
        QT.LIBELLÉ AS QuartDeTravail,
        COUNT(DISTINCT IA.ID_INTERVENTION) AS NbInterventionsRepertoriees 
    FROM
        INTERVENTION_AGENT AS IA
    INNER JOIN
        AGENT AS A ON IA.MATRICULE_AGENT = A.MATRICULE
    INNER JOIN
        POSTE_DE_QUARTIER AS PDQ ON A.PDQ = PDQ.ID_PDQ
    INNER JOIN
        INTERVENTION AS I ON IA.ID_INTERVENTION = I.ID_INTERVENTION
    INNER JOIN
        QUART_TRAVAIL AS QT ON I.ID_QUART_TRAVAIL = QT.ID
    GROUP BY
        PDQ.ID_PDQ, DATEFROMPARTS(YEAR(I.DATE_INCIDENT), MONTH(I.DATE_INCIDENT), 1), QT.LIBELLÉ;
END;

-- Executer la procédure stockée
EXEC spInitSuiviInterventions;

-- Verifier si on a reussi
SELECT * FROM suiviInterventions ORDER BY 1, 2, 3;

/* 
5. (FINI)
Écrire une procédure stockée dont l’identificateur est « spMAJMensuelleSuiviInterventions » qui sera exécutée 
automatiquement par le système à chaque dernier jour de mois à 23h59m59s (Vous n’avez pas à implémenter cette 
exécution automatique, notion non abordée en classe). Cette procédure stockée aura pour vocation d’ajouter à la table
« suiviInterventions» (Créée et peuplée dans la question précédente), le nombre d’interventions policières 
répertoriées par quart de travail, pour chaque poste de quartier du mois qui vient de s’écouler.
La procédure stockée permet donc une mise à jour de la table « suiviInterventions » en ajoutant de nouvelles entrées 
pour le mois qui vient de s’écouler.
*/ 


DROP PROCEDURE IF EXISTS spMAJMensuelleSuiviInterventions;
GO

CREATE PROCEDURE spMAJMensuelleSuiviInterventions
AS
BEGIN
    DECLARE @Mois DATE;

    -- mois et année
    SET @Mois = DATEFROMPARTS(YEAR(GETDATE()), MONTH(GETDATE()), 1);

    -- vérifier si nous n'avons pas déjà exécuté la procédure stockée
    IF NOT EXISTS (SELECT 1 FROM suiviInterventions WHERE AnneeMois = @Mois)
    BEGIN
        -- Inserer des données
        INSERT INTO suiviInterventions (PosteDeQuartier, AnneeMois, QuartDeTravail, NbInterventionsRepertoriees)
        SELECT
            PDQ.ID_PDQ AS PosteDeQuartier,
            @Mois AS AnneeMois,
            QT.LIBELLÉ AS QuartDeTravail,
            COUNT(DISTINCT IA.ID_INTERVENTION) AS NbInterventionsRepertoriees
        FROM
            INTERVENTION_AGENT AS IA
        INNER JOIN
            AGENT AS A ON IA.MATRICULE_AGENT = A.MATRICULE
        INNER JOIN
            POSTE_DE_QUARTIER AS PDQ ON A.PDQ = PDQ.ID_PDQ
        INNER JOIN
            INTERVENTION AS I ON IA.ID_INTERVENTION = I.ID_INTERVENTION
        INNER JOIN
            QUART_TRAVAIL AS QT ON I.ID_QUART_TRAVAIL = QT.ID
        WHERE
            I.DATE_INCIDENT >= @Mois
            AND I.DATE_INCIDENT < DATEADD(MONTH, 1, @Mois)
        GROUP BY
            PDQ.ID_PDQ, QT.LIBELLÉ;

        -- Afficher un message indiquant que la mise à jour a été effectuée avec succès ou pas
        PRINT 'Mise à jour effectuée pour : ' + FORMAT(@Mois, 'yyyy-MM');
    END
    ELSE
    BEGIN
        -- Exécution subséquente de la procédure stockée lors d’un même mois
        PRINT 'Mise à jour déjà effectuée pour : ' + FORMAT(@Mois, 'yyyy-MM');
    END
END;

-- Créer un exemple our verifier si on a reussi à créer cette procédure stockée
INSERT INTO INTERVENTION_AGENT (ID_INTERVENTION, MATRICULE_AGENT)
VALUES
    (1, 101);

-- Executer la proc´dure stockée
EXEC spMAJMensuelleSuiviInterventions;

-- Verifier la table mis à jour
SELECT * FROM suiviInterventions ORDER BY 1;